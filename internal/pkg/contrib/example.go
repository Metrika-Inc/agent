// Copyright 2022 Metrika Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package contrib

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"

	"agent/api/v1/model"
	"agent/internal/pkg/global"

	"github.com/mitchellh/mapstructure"
	"go.uber.org/zap"
)

// This is an example implementation of the global.Stream interface
// and its sole purpose is to demonstrate how to access the stream
// of data generated by the agent. It will marshal all messages
// consumed to JSON and write them under $HOME/.cache/agent_stream.log.

type logLine struct {
	Hostname string              `json:"hostname"`
	Mf       *model.MetricFamily `json:"mf,omitempty"`
	Ev       *model.Event        `json:"ev,omitempty"`
}

type jsonProcessor struct{}

func (m *jsonProcessor) Process(msg *model.Message) ([]byte, error) {
	var err error
	line := &logLine{Hostname: global.AgentHostname}

	if msg.GetMetricFamily() != nil {
		line.Mf = msg.GetMetricFamily()
	} else if msg.GetEvent() != nil {
		line.Ev = msg.GetEvent()
	} else {
		zap.S().Errorf("dropping message without a value")

		return nil, err
	}

	bytes, err := json.Marshal(&line)
	if err != nil {
		return nil, err
	}

	return bytes, nil
}

type fileStream struct {
	fileStreamConfig
	*jsonProcessor

	file  *os.File
}

type fileStreamConfig struct {
	OutPath string `mapstructure:"output_path"`
}

func newFileStream(config any) (global.Exporter, error) {
	var cfg fileStreamConfig

	if err := mapstructure.Decode(config, &cfg); err != nil {
		return nil, err
	}

	// set defaults if not set
	if len(cfg.OutPath) == 0 {
		cfg.OutPath = filepath.Join(global.AgentCacheDir, "agent_stream.log")
	}

	file, err := os.OpenFile(cfg.OutPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0o755)
	if err != nil {
		return nil, err
	}

	return &fileStream{fileStreamConfig: cfg, jsonProcessor: &jsonProcessor{}, file: file}, nil
}

func (m *fileStream) HandleMessage(ctx context.Context, msg *model.Message) {
	log := zap.S()

	select {
	case <-ctx.Done():
		if err := m.file.Close(); err != nil {
			log.Warnw("close error", zap.Error(err))
		}

		return
	default:
	}
	body, err := m.Process(msg)
	if err != nil {
		log.Errorw("file stream handle error", zap.Error(err))
	}

	if _, err := m.file.Write(append(body, '\n')); err != nil {
		log.Errorw("write error", zap.Error(err))
	}
}
