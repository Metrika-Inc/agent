package contrib

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"

	"agent/api/v1/model"
	"agent/internal/pkg/global"

	"go.uber.org/zap"
)

// This is an example implementation of the global.Stream interface
// and its sole purpose is to demonstrate how to access the stream
// of data generated by the agent. It will marshal all messages
// consumed to JSON and write them under $HOME/.cache/agent_stream.log.

type logLine struct {
	Hostname string              `json:"hostname"`
	Mf       *model.MetricFamily `json:"mf,omitempty"`
	Ev       *model.Event        `json:"ev,omitempty"`
}

type jsonProcessor struct{}

func (m *jsonProcessor) Process(msg *model.Message) ([]byte, error) {
	var err error
	line := &logLine{Hostname: global.AgentHostname}

	if msg.GetMetricFamily() != nil {
		line.Mf = msg.GetMetricFamily()
	} else if msg.GetEvent() != nil {
		line.Ev = msg.GetEvent()
	} else {
		zap.S().Errorf("dropping message without a value")

		return nil, err
	}

	bytes, err := json.Marshal(&line)
	if err != nil {
		return nil, err
	}

	return bytes, nil
}

type fileStream struct {
	*jsonProcessor

	ch chan interface{}
	f  *os.File
}

func newFileStream() (global.Exporter, error) {
	outPath := filepath.Join(global.AgentCacheDir, "agent_stream.log")

	f, err := os.OpenFile(outPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0o755)
	if err != nil {
		return nil, err
	}

	return &fileStream{jsonProcessor: &jsonProcessor{}, f: f}, nil
}

func (m *fileStream) HandleMessage(ctx context.Context, msg *model.Message) {
	log := zap.S()

	select {
	case <-ctx.Done():
		if err := m.f.Close(); err != nil {
			log.Warnw("close error", zap.Error(err))
		}

		return
	default:
	}
	body, err := m.Process(msg)
	if err != nil {
		log.Errorw("file stream handle error", zap.Error(err))
	}

	if _, err := m.f.Write(append(body, '\n')); err != nil {
		log.Errorw("write error", zap.Error(err))
	}
}
